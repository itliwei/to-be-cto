## 算法

[TOC]

### 算法标准

#### 时间复杂度

在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)的**时间复杂度**（Time complexity）是一个[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0)，它定性描述该算法的运行时间。这是一个代表算法输入值的[字符串](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2)的长度的函数。时间复杂度常用[大O符号](https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7)表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是[渐近](https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90)的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 *n* （必须比 *n0* 大）的输入，它至多需要 5*n*3 + 3*n* 的时间运行完毕，那么它的渐近时间复杂度是 O(*n*3)。

为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。

相同大小的不同输入值仍可能造成算法的运行时间不同，因此我们通常使用算法的[最坏情况复杂度](https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%A3%9E%E6%83%85%E6%B3%81%E8%A4%87%E9%9B%9C%E5%BA%A6&action=edit&redlink=1)，记为 **T(n)** ，定义为任何大小的输入 *n* 所需的最大运行时间。另一种较少使用的方法是[平均情况复杂度](https://zh.wikipedia.org/w/index.php?title=%E5%B9%B3%E5%9D%87%E6%83%85%E6%B3%81%E8%A4%87%E9%9B%9C%E5%BA%A6&action=edit&redlink=1)，通常有特别指定才会使用。时间复杂度可以用函数 *T*(*n*) 的自然特性加以分类，举例来说，有着 *T*(*n*) = *O*(*n*) 的算法被称作“线性时间算法”；而 *T*(*n*) = *O*(*M**n*) 和 *M**n*= O(*T*(*n*)) ，其中 *M* ≥ *n* > 1 的算法被称作“指数时间算法”。



测试环境

数据集规模

#### 空间复杂度

占用内存空间



时间换空间

空间换时间



### 算法分类

#### 1.线性表(数组)

内存连续，有大小限制，不便于扩容

插入O(n)

删除O(n)

查找O(1)



#### 2. 链表



内存无需连续，无大小限制，便于扩容。

哨兵节点

##### 1.单向链表

插入O(1)

删除O(1)

查找O(n)

```java
class Node(){
	Object data;
	Node next;
}
```



##### 2.循环链表



##### 3.双向链表

无需找到前驱节点

```java
class Node(){
    Node pre;
	Object data;
	Node next;
}
```

删除O(1)

插入O(1)



4.翻转链表



#### 栈

#### 队列

#### 二分查找

#### 双指针

 