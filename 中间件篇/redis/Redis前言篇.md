### 一、Redis的由来

2008年，Redis的作者antirez写了一个网站，在使用mysql数据的时候在最大负载达到每秒数千条页面记录的情况下，无论使用什么样的数据库模式（schema），无论如何进行优化，所使用的关系数据库都没办法在这个小虚拟机上处理如此大的负载。最终，决定自己写一个实验性质的内存数据库原型（prototype），这个数据库使用列表作为基本数据类型，并且能够对列表的两端执行常数时间复杂度的弹出（pop）和推入（push）操作。而这个项目最后就发展成了如今大名鼎鼎的Redis。

Redis(REmote DIctionary Service) 翻译过来就是远程字典服务。

从Redis诞生的背景可以看出，关系型数据库并不适合所有场景。那么关系型数据库和非关系型数据库到底有什么区别呢？

### 二、关系型数据VS非关系型数据库
一般情况下我们都会使用关系型数据库存储业务数据，比如SQL Server、MySql、Oracle等主流数据库。简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。

关系模型中常用的概念：

> **关系**：可以理解为一张二维表，每个关系都具有一个关系名，就是通常说的表名
>
> **元组**：可以理解为二维表中的一行，在数据库中经常被称为记录
>
> **属性**：可以理解为二维表中的一列，在数据库中经常被称为字段
>
> **域**：属性的取值范围，也就是数据库中某一列的取值限制
>
> **关键字**：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成
>
> **关系模式**：指对关系的描述。其格式为：关系名(属性1，属性2， ... ... ，属性N)，在数据库中成为表结构

当今十大主流的关系型数据库

**Oracle，Microsoft SQL Server，MySQL，PostgreSQL，DB2，**
**Microsoft Access， SQLite，Teradata，MariaDB(MySQL的一个分支)，SAP**

**关系型数据库的优点：**

- **容易理解**：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解
- **使用方便**：通用的SQL语言使得操作关系型数据库非常方便
- **易于维护**：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率

但是关系型数据库也有它的一些限制，比如：

1. 关系型数据库会将数据持久化到磁盘，难以支撑高并发的读写需求；
2. 海量数据读写效率低，如果要解决这个问题只能垂直扩容，磁盘受限了就扩大磁盘，如果水平扩容即分库分表技术复杂。
3. 表结构修改困难，尤其是在数据量大的时候。

为了解决关系型数据库的一系列问题，所以衍生出了**非关系型数据库**。

NoSQL一词首先是Carlo Strozzi在1998年提出来的，指的是他开发的一个没有SQL功能，轻量级的，开源的关系型数据库。这个定义跟我们现在对NoSQL的定义有很大的 区别，它确确实实字如其名，指的就是“没有SQL”的数据库。但是NoSQL的发展慢慢偏离了初衷，我们要的不是“no sql”，而是“no relational”，也就是我们现在常说的非关系型数据库了。


非关系型数据库以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。

**非关系型数据库的优点：**

1. 存储非结构化数据，可以灵活修改字段

2. 表与表之间没有关联，便于拓展

3. 不支持事务，保证最终一致性

4. 支持海量数据的存储和高并发的读写

5. 支持分布式，可对数据进行分片和扩容

非关系型数据库都是针对某些特定的应用需求出现的，因此，对于该类应用具有极高的性能。依据结构化方法以及应用场合的不同，主要分为以下几类：

##### 面向高性能并发读写的key-value数据库：

> key-value数据库的主要特点是具有极高的并发读写性能
> Key-value数据库是一种以键值对存储数据的一种数据库，类似Java中的map。可以将整个数据库理解为一个大的map，每个键都会对应一个唯一的值。主流代表为:
>
> **Redis， Amazon DynamoDB， Memcached，Microsoft Azure Cosmos DB和Hazelcast**

##### 面向海量数据访问的面向文档数据库：

> 这类数据库的主要特点是在海量的数据中可以快速的查询数据
> 文档存储通常使用内部表示法，可以直接在应用程序中处理，主要是JSON。JSON文档也可以作为纯文本存储在键值存储或关系数据库系统中。主流代表为:
>
> **MongoDB，Amazon DynamoDB，Couchbase，icrosoft Azure Cosmos DB和CouchDB**

##### 面向搜索数据内容的搜索引擎：

> 搜索引擎是专门用于搜索数据内容的NoSQL数据库管理系统。
> 主要是用于对海量数据进行近实时的处理和分析处理，可用于机器学习和数据挖掘。主流代表为:
>
> **Elasticsearch，Splunk，Solr，MarkLogic和Sphinx**

##### 面向可扩展性的分布式数据库：

> 这类数据库的主要特点是具有很强的可拓展性
> 普通的关系型数据库都是以行为单位来存储数据的，擅长以行为单位的读入处理，比如特定条件数据的获取。因此，关系型数据库也被成为面向行的数据库。相反，面向列的数据库是以列为单位来存储数据的，擅长以列为单位读入数据。
> 这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化，将数据存储在记录中，能够容纳大量动态列。由于列名和记录键不是固定的，并且由于记录可能有数十亿列，因此可扩展性存储可以看作是二维键值存储。主流代表为：
>
> **Cassandra，HBase，Microsoft Azure Cosmos DB，Datastax Enterprise和Accumulo**

从上面的内容大家可以看出，SQL或者NoSQL各有利弊，那能不能让他们结合一下呢？

当然可以！就是现在所谓的NewSQL数据库。例如TiDB(PingCAP)、VoltDB、ScaleDB等。它们提供与NOSQL相同的可扩展性和性能，同时能支持满足ACID特性的事务，即保持NoSQL的高可扩展和高性能，并且保持关系模型。关于NewSQL不是本文重点，我们以后有机会再细聊。

那么Redis作为其中一款非关系型数据库，它究竟有哪些特性呢？

### 三、Redis的特性

对于Redis，我们大多数人都认为是一个缓存中间件，但是从它的产生背景也可以看到它不是作为一个缓存中间件来使用的。只是后来在我们目前的应用里面，它作为缓存发挥了很大的作用。所以接下来就聊一聊Redis究竟有哪些特性。

由上文我们知道了Redis是一个面向高性能并发读写的key-value数据库。

那么为什么把数据放在内存呢？​	

> 快！内存的速度更快，同时能减少磁盘的压力。

OK，那为什么不直接放在类似于java里的map里呢？

> 1、Redis有更丰富的数据结构，更丰富的功能
>
> 2、Redis支持分布式，map里只能单点
>
> 3、Redis有完善的持久化机制，避免数据丢失，map里一旦重启就没了
>
> 4、Redis支持多种语言，map只有java，每个语言之间不同

OK，到这里为止，Redis的特性基本就明确了。

**1. 速度快**

正常情况下，Redis执行命令的速度非常快，官方给出的数字是读写性能可以达到10万/秒，当然这也取决于机器的性能，但这里先不讨论机器性能上的差异，只分析一下是什么造就了Redis除此之快的速度，可以大致归纳为以下三点：

- Redis的所有数据都是存放在内存中的，所以把数据放在内存中是Redis速度快的最主要原因。
- Redis是用C语言实现的，一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。
- Redis使用了单线程架构，预防了多线程可能产生的竞争问题。

**2. 基于键值对的数据结构服务器**

几乎所有的编程语言都提供了类似字典的功能，例如Java里的map、Python里的dict，类似于这种组织数据的方式叫作基于键值的方式，与很多键值对数据库不同的是，Redis中的值不仅可以是字符串，而且还可以是具体的数据结构，这样不仅能便于在许多应用场景的开发，同时也能够提高开发效率。

**3. 丰富的功能**

除了 [strings](https://redis.io/topics/data-types-intro#strings), [hashes](https://redis.io/topics/data-types-intro#hashes), [lists](https://redis.io/topics/data-types-intro#lists), [sets](https://redis.io/topics/data-types-intro#sets), [sorted sets](https://redis.io/topics/data-types-intro#sorted-sets) 5种基本数据结构外，还提供了 [bitmaps](https://redis.io/topics/data-types-intro#bitmaps), [hyperloglogs](https://redis.io/topics/data-types-intro#hyperloglogs), [geospatial indexes](https://redis.io/commands/geoadd), 和 [streams](https://redis.io/topics/streams-intro)。除了丰富的数据结构，Redis还提供了许多额外的功能：

- [Redis as an LRU cache](https://redis.io/topics/lru-cache)：提供了键过期功能，可以用来实现缓存。
- [Pub/Sub](https://redis.io/topics/pubsub)：提供了发布订阅功能，可以用来实现消息系统。
- [Lua scripting](https://redis.io/commands/eval)：支持Lua脚本功能，可以利用Lua创造出新的Redis命令。
- [Transactions](https://redis.io/topics/transactions)：提供了简单的事务功能，能在一定程度上保证事务特性。
- [Pipelining](https://redis.io/topics/pipelining): 提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传到Redis，减少了网络的开销。

**4. 客户端语言多**

Redis提供了简单的TCP通信协议，很多编程语言可以很方便地接入到Redis，并且由于Redis受到社区和各大公司的广泛认可，所以支持Redis的客户端语言也非常多，几乎涵盖了主流的编程语言，例如Java、PHP、Python、C、C++、Nodejs等。更多参考：https://redis.io/clients

**5.持久化**

通常看，将数据放在内存中是不安全的，一旦发生断电或者机器故障，重要的数据可能就会丢失，因此Redis提供了两种持久化方式：RDB和AOF，即可以用两种策略将内存的数据保存到硬盘中这样就保证了数据的可持久性。

**6.主从复制**

Redis提供了复制功能，实现了多个相同数据的Redis副本，复制功能是分布式Redis的基础。

**7.高可用和分布式**

Redis从2.8版本正式提供了高可用实现Redis Sentinel，它能够保证Redis节点的故障发现和故障自动转移。Redis从3.0版本正式提供了分布式实现Redis Cluster，它是Redis真正的分布式实现，提供了高可用、读写和容量的扩展性。



以上特性，Redis是如何实现的呢？我们下文分析。

